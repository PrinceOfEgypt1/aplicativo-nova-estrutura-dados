===== index.ts =====
// src/components/DataStructures/Vetor/index.ts
export { default as VisualizacaoVetor } from './VisualizacaoVetor';
export * from './metodosVetor';
export * from './useVetor';
export * from './vetor';
export * from './InformacoesVetor';


===== InformacoesVetor.tsx =====
// src/components/DataStructures/Vetor/InformacoesVetor.tsx
import { metodosInfo } from "./metodosVetor";

export function InformacoesVetor() {
  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-bold">Vetor</h2>
      <p className="text-gray-600 dark:text-gray-300">
        Vetor e uma estrutura de dados que armazena elementos de tamanho fixo
        sequencialmente na memoria. Eles permitem acesso rapido aos elementos
        atraves dos indices.
      </p>
      <div className="space-y-2">
        <h3 className="text-xl font-semibold">Metodos Disponiveis</h3>
        <ul className="space-y-2">
          {Object.entries(metodosInfo).map(([chave, metodo]) => (
            <li key={chave} className="border-l-4 border-blue-500 pl-4">
              <h4 className="font-mono font-bold">{metodo.titulo}</h4>
              <p className="text-sm text-gray-600 dark:text-gray-400">
                {metodo.descricao}
              </p>
              {metodo.requisitos.length > 0 && (
                <p className="text-sm font-mono text-gray-500 dark:text-gray-400">
                  Parametros: {metodo.requisitos.join(", ")}
                </p>
              )}
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
}


===== merge-files.ps1 =====
# Diret√≥rio dos arquivos
$sourceDirectory = "C:\Users\Projetos\aplicativo-nova-estrutura-dados\src\components\DataStructures\Vetor"

# Caminho do arquivo de sa√≠da
$outputFile = "$sourceDirectory\arquivos_concatenados.txt"

# Verifica se o arquivo de sa√≠da j√° existe e remove
if (Test-Path $outputFile) {
    Remove-Item $outputFile
}

# Percorre todos os arquivos no diret√≥rio
Get-ChildItem -Path $sourceDirectory -File | ForEach-Object {
    $filePath = $_.FullName
    $fileName = $_.Name

    # Adiciona o cabe√ßalho com o nome do arquivo ao arquivo de sa√≠da
    Add-Content -Path $outputFile -Value "===== $fileName ====="

    # L√™ o conte√∫do do arquivo e adiciona ao arquivo de sa√≠da
    Get-Content -Path $filePath | Add-Content -Path $outputFile

    # Adiciona uma linha em branco para separar os arquivos
    Add-Content -Path $outputFile -Value "`n"
}

Write-Host "Arquivos combinados com sucesso em: $outputFile"


===== metodosVetor.ts =====
// src/components/DataStructures/Vetor/metodosVetor.ts
// Defini√ß√£o das interfaces dentro do pr√≥prio arquivo para manter a estrutura
interface MetodoInfo {
  titulo: string;
  descricao: string;
  requisitos: string[];
}

// Exporta√ß√£o dos grupos de m√©todos
export const gruposMetodos = {
  basicos: ['inserir', 'remover', 'pesquisar', 'obterElemento', 'definirElemento'],
  informacao: ['tamanho', 'estaVazio'],
  manipulacao: ['limpar', 'ordenar', 'inverter'],
  final: ['adicionarNoFinal', 'removerDoFinal', 'estender'],
  busca: ['fatiar', 'contem', 'indiceDe']
} as const;

// Tipagem para os grupos de m√©todos
export type GrupoMetodo = keyof typeof gruposMetodos;

// Defini√ß√£o e exporta√ß√£o dos m√©todos dispon√≠veis
export const metodosInfo: Record<string, MetodoInfo> = {
  inserir: {
    titulo: "Inserir",
    descricao: "Adiciona um elemento em uma posi√ß√£o espec√≠fica",
    requisitos: ["Solicitar um valor", "Solicitar um √≠ndice"]
  },
  remover: {
    titulo: "Remover",
    descricao: "Remove um elemento de uma posi√ß√£o espec√≠fica",
    requisitos: ["Solicitar um √≠ndice"]
  },
  pesquisar: {
    titulo: "Pesquisar",
    descricao: "Busca um elemento no vetor",
    requisitos: ["Solicitar um valor"]
  },
  obterElemento: {
    titulo: "Obter Elemento",
    descricao: "Retorna o elemento em uma posi√ß√£o espec√≠fica",
    requisitos: ["Solicitar um √≠ndice"]
  },
  definirElemento: {
    titulo: "Definir Elemento",
    descricao: "Atualiza o valor de um elemento em uma posi√ß√£o espec√≠fica",
    requisitos: ["Solicitar um valor", "Solicitar um √≠ndice"]
  },
  tamanho: {
    titulo: "Tamanho",
    descricao: "Retorna o n√∫mero atual de elementos no vetor",
    requisitos: []
  },
  estaVazio: {
    titulo: "Est√° Vazio",
    descricao: "Verifica se o vetor n√£o cont√©m elementos",
    requisitos: []
  },
  limpar: {
    titulo: "Limpar",
    descricao: "Remove todos os elementos do vetor",
    requisitos: []
  },
  ordenar: {
    titulo: "Ordenar",
    descricao: "Reorganiza os elementos em ordem crescente",
    requisitos: []
  },
  inverter: {
    titulo: "Inverter",
    descricao: "Inverte a ordem atual dos elementos no vetor",
    requisitos: []
  },
  adicionarNoFinal: {
    titulo: "Adicionar no Final",
    descricao: "Insere um novo elemento na √∫ltima posi√ß√£o do vetor",
    requisitos: ["Solicitar um valor"]
  },
  estender: {
    titulo: "Estender",
    descricao: "Adiciona m√∫ltiplos elementos ao final do vetor",
    requisitos: ["Solicitar valores separados por v√≠rgula"]
  },
  removerDoFinal: {
    titulo: "Remover do Final",
    descricao: "Remove e retorna o √∫ltimo elemento do vetor",
    requisitos: []
  },
  fatiar: {
    titulo: "Fatiar",
    descricao: "Cria um novo vetor com elementos entre dois √≠ndices",
    requisitos: ["Solicitar √≠ndice inicial", "Solicitar √≠ndice final"]
  },
  contem: {
    titulo: "Cont√©m",
    descricao: "Verifica se um determinado elemento existe no vetor",
    requisitos: ["Solicitar um valor"]
  },
  indiceDe: {
    titulo: "√çndice De",
    descricao: "Retorna a posi√ß√£o da primeira ocorr√™ncia do elemento",
    requisitos: ["Solicitar um valor"]
  }
};


===== useVetor.ts =====
// src/components/DataStructures/Vetor/useVetor.ts
import { useState, useCallback } from "react";

// Defini√ß√£o dos tipos b√°sicos utilizados no vetor
interface VectorElement {
  value: number;  // Armazena o n√∫mero inteiro
  id: string;     // Identificador √∫nico do elemento
}

interface OperationHistory {
  operacao: string;   // Descri√ß√£o da opera√ß√£o realizada
  timestamp: number;  // Momento em que a opera√ß√£o ocorreu
}

// Sistema centralizado de valida√ß√µes matem√°ticas
const validacoes = {
  /**
   * Valida se um valor √© um n√∫mero inteiro v√°lido usando princ√≠pios matem√°ticos.
   * Um n√∫mero √© inteiro se e somente se ele √© igual ao seu pr√≥prio floor (parte inteira).
   */
  validarNumero(valor: any): { valido: boolean; mensagem: string; valor?: number } {
    // Valida√ß√£o de valor nulo ou indefinido
    if (valor === undefined || valor === null) {
      return { 
        valido: false, 
        mensagem: 'O valor n√£o pode estar vazio' 
      };
    }

    // Normaliza√ß√£o da entrada para string
    const valorString = String(valor).trim();
    
    // Valida√ß√£o de string vazia
    if (valorString === '') {
      return { 
        valido: false, 
        mensagem: 'O valor n√£o pode estar vazio' 
      };
    }

    // Convers√£o para n√∫mero e valida√ß√£o matem√°tica
    const numeroConvertido = Number(valorString);

    // Verifica se √© um n√∫mero v√°lido (n√£o NaN)
    if (isNaN(numeroConvertido)) {
      return {
        valido: false,
        mensagem: 'O valor deve ser um n√∫mero'
      };
    }

    // Verifica√ß√£o matem√°tica de n√∫mero inteiro
    // Um n√∫mero √© inteiro se e somente se ele √© igual ao seu pr√≥prio floor
    if (numeroConvertido !== Math.floor(numeroConvertido)) {
      return {
        valido: false,
        mensagem: 'O valor deve ser um n√∫mero inteiro (sem decimais)'
      };
    }

    // Valida√ß√£o do intervalo permitido
    if (numeroConvertido < -1000 || numeroConvertido > 1000) {
      return {
        valido: false,
        mensagem: 'O valor deve estar entre -1000 e 1000'
      };
    }

    return {
      valido: true,
      mensagem: 'Valor v√°lido',
      valor: numeroConvertido
    };
  },

  /**
   * Valida se um √≠ndice √© v√°lido para o vetor atual.
   * Um √≠ndice v√°lido deve ser um n√∫mero inteiro n√£o negativo dentro dos limites do vetor.
   */
  validarIndice(indice: number, tamanhoAtual: number, capacidadeMaxima: number): { valido: boolean; mensagem: string } {
    // Verifica se o √≠ndice √© um n√∫mero inteiro
    if (typeof indice !== 'number' || indice !== Math.floor(indice)) {
      return { 
        valido: false, 
        mensagem: 'O √≠ndice deve ser um n√∫mero inteiro' 
      };
    }

    // Verifica se o √≠ndice √© n√£o-negativo
    if (indice < 0) {
      return { 
        valido: false, 
        mensagem: 'O √≠ndice n√£o pode ser negativo' 
      };
    }

    // Verifica se o √≠ndice est√° dentro da capacidade m√°xima
    if (indice > tamanhoAtual && indice >= capacidadeMaxima) {
      return { 
        valido: false, 
        mensagem: `O √≠ndice n√£o pode ser maior que ${capacidadeMaxima - 1}` 
      };
    }

    // Verifica se n√£o h√° lacunas no vetor
    if (indice > tamanhoAtual) {
      return { 
        valido: false, 
        mensagem: `O √≠ndice n√£o pode ter lacunas. Pr√≥ximo √≠ndice v√°lido: ${tamanhoAtual}` 
      };
    }

    return { 
      valido: true, 
      mensagem: '√çndice v√°lido' 
    };
  }
};

/**
 * Hook principal para manipula√ß√£o do vetor
 * @param capacidadeInicial Capacidade m√°xima do vetor (padr√£o: 20)
 */
export function useVetor(capacidadeInicial: number = 20) {
  // Estados principais do hook
  const [elementos, setElementos] = useState<VectorElement[]>([]);
  const [historico, setHistorico] = useState<OperationHistory[]>([]);
  const [mensagemAcao, setMensagemAcao] = useState<string | null>(null);
  const [indiceDestacado, setIndiceDestacado] = useState<number | undefined>();

  // Registra opera√ß√µes no hist√≥rico
  const registrarOperacao = useCallback((operacao: string) => {
    setHistorico(prev => [{
      operacao,
      timestamp: Date.now()
    }, ...prev]);
    setMensagemAcao(operacao);
  }, []);

  // Valida√ß√£o de √≠ndices contextual
  const validarIndice = useCallback((indice: number, permiteIgualTamanho: boolean = false) => {
    const resultado = validacoes.validarIndice(
      indice,
      elementos.length,
      permiteIgualTamanho ? capacidadeInicial : capacidadeInicial - 1
    );
    
    if (!resultado.valido) {
      throw new Error(resultado.mensagem);
    }
  }, [elementos.length, capacidadeInicial]);

  // Executor principal de m√©todos do vetor
  const executarMetodo = useCallback(async (metodo: string, ...args: any[]) => {
    try {
      let resultado: any;
      
      switch (metodo) {
        case "inserir": {
          const [valorBruto, indiceBruto] = args;
          
          // Valida√ß√£o matem√°tica do valor
          const validacaoValor = validacoes.validarNumero(valorBruto);
          if (!validacaoValor.valido) {
            throw new Error(validacaoValor.mensagem);
          }

          const indice = Number(indiceBruto);
          if (elementos.length >= capacidadeInicial) {
            throw new Error('Vetor est√° cheio');
          }
          validarIndice(indice, true);

          const novosElementos = [...elementos];
          novosElementos.splice(indice, 0, { 
            value: validacaoValor.valor!, 
            id: Date.now().toString() 
          });
          
          setElementos(novosElementos);
          setIndiceDestacado(indice);
          registrarOperacao(`Elemento ${validacaoValor.valor} inserido na posi√ß√£o ${indice}`);
          break;
        }

        case "definirElemento": {
          const [valorBruto, indiceBruto] = args;
          
          const validacaoValor = validacoes.validarNumero(valorBruto);
          if (!validacaoValor.valido) {
            throw new Error(validacaoValor.mensagem);
          }

          const indice = Number(indiceBruto);
          validarIndice(indice);

          const novosElementos = [...elementos];
          novosElementos[indice] = { 
            value: validacaoValor.valor!, 
            id: Date.now().toString() 
          };
          
          setElementos(novosElementos);
          setIndiceDestacado(indice);
          registrarOperacao(`Elemento ${validacaoValor.valor} definido na posi√ß√£o ${indice}`);
          break;
        }

        case "remover": {
          const [indiceBruto] = args;
          const indice = Number(indiceBruto);
          validarIndice(indice);

          if (elementos.length === 0) {
            throw new Error('Vetor est√° vazio');
          }

          const novosElementos = [...elementos];
          const elementoRemovido = novosElementos.splice(indice, 1)[0];
          setElementos(novosElementos);
          registrarOperacao(`Elemento ${elementoRemovido.value} removido da posi√ß√£o ${indice}`);
          break;
        }

        case "pesquisar": {
          const [valorBruto] = args;
          const validacaoValor = validacoes.validarNumero(valorBruto);
          if (!validacaoValor.valido) {
            throw new Error(validacaoValor.mensagem);
          }

          const indice = elementos.findIndex(el => el.value === validacaoValor.valor);
          if (indice >= 0) {
            setIndiceDestacado(indice);
            registrarOperacao(`Elemento ${validacaoValor.valor} encontrado na posi√ß√£o ${indice}`);
          } else {
            registrarOperacao(`Elemento ${validacaoValor.valor} n√£o encontrado`);
          }
          resultado = indice;
          break;
        }

        case "obterElemento": {
          const [indiceBruto] = args;
          const indice = Number(indiceBruto);
          validarIndice(indice);

          setIndiceDestacado(indice);
          resultado = elementos[indice].value;
          registrarOperacao(`Elemento obtido da posi√ß√£o ${indice}: ${resultado}`);
          break;
        }

        case "tamanho": {
          resultado = elementos.length;
          registrarOperacao(`Vetor possui ${resultado} elementos`);
          break;
        }

        case "estaVazio": {
          resultado = elementos.length === 0;
          registrarOperacao(`Vetor ${resultado ? 'est√°' : 'n√£o est√°'} vazio`);
          break;
        }

        case "limpar": {
          setElementos([]);
          registrarOperacao('Vetor foi limpo');
          break;
        }

        case "ordenar": {
          const novosElementos = [...elementos].sort((a, b) => a.value - b.value);
          setElementos(novosElementos);
          registrarOperacao('Vetor foi ordenado');
          break;
        }

        case "inverter": {
          setElementos(prev => [...prev].reverse());
          registrarOperacao('Vetor foi invertido');
          break;
        }

        case "adicionarNoFinal": {
          const [valorBruto] = args;
          
          const validacaoValor = validacoes.validarNumero(valorBruto);
          if (!validacaoValor.valido) {
            throw new Error(validacaoValor.mensagem);
          }

          if (elementos.length >= capacidadeInicial) {
            throw new Error('Vetor est√° cheio');
          }

          setElementos(prev => [...prev, { 
            value: validacaoValor.valor!, 
            id: Date.now().toString() 
          }]);
          setIndiceDestacado(elementos.length);
          registrarOperacao(`Elemento ${validacaoValor.valor} adicionado ao final`);
          break;
        }

        case "estender": {
          const [valoresString] = args;
          const valoresBrutos = valoresString.split(',').map((v: string) => v.trim());
          
          const valoresValidados = [];
          for (const valor of valoresBrutos) {
            const validacao = validacoes.validarNumero(valor);
            if (!validacao.valido) {
              throw new Error(`Valor inv√°lido na lista: ${valor}`);
            }
            valoresValidados.push(validacao.valor!);
          }

          if (elementos.length + valoresValidados.length > capacidadeInicial) {
            throw new Error('Capacidade do vetor seria excedida');
          }

          const elementosAdicionados = valoresValidados.map(valor => ({
            value: valor,
            id: Date.now().toString() + Math.random()
          }));

          setElementos(prev => [...prev, ...elementosAdicionados]);
          registrarOperacao(`${valoresValidados.length} elementos adicionados ao final`);
          break;
        }

        case "removerDoFinal": {
          if (elementos.length === 0) {
            throw new Error('Vetor est√° vazio');
          }

          const elementoRemovido = elementos[elementos.length - 1].value;
          setElementos(prev => prev.slice(0, -1));
          registrarOperacao(`Elemento ${elementoRemovido} removido do final`);
          break;
        }

        case "fatiar": {
          const [inicioBruto, fimBruto] = args;
          
          const inicio = Number(inicioBruto);
          if (!Number.isInteger(inicio) || inicio < 0 || inicio >= elementos.length) {
            throw new Error('√çndice inicial inv√°lido');
          }

          const fim = fimBruto === undefined ? elementos.length : Number(fimBruto);
          if (!Number.isInteger(fim) || fim < inicio || fim > elementos.length) {
            throw new Error('√çndice final inv√°lido');
          }
          
          const elementosFatiados = elementos.slice(inicio, fim);
          const valoresFatiados = elementosFatiados.map(el => el.value);
          resultado = valoresFatiados;
          
          registrarOperacao(`Vetor fatiado: [${valoresFatiados.join(', ')}]`);
          break;
        }

        case "contem": {
          const [valorBruto] = args;
          const validacaoValor = validacoes.validarNumero(valorBruto);
          if (!validacaoValor.valido) {
            throw new Error(validacaoValor.mensagem);
          }

          resultado = elementos.some(el => el.value === validacaoValor.valor);
          registrarOperacao(`Elemento ${validacaoValor.valor} ${resultado ? 'encontrado' : 'n√£o encontrado'} no vetor`);
          break;
        }

        case "indiceDe": {
          const [valorBruto] = args;
          const validacaoValor = validacoes.validarNumero(valorBruto);
          if (!validacaoValor.valido) {
            throw new Error(validacaoValor.mensagem);
          }

          resultado = elementos.findIndex(el => el.value === validacaoValor.valor);
          if (resultado >= 0) {
            setIndiceDestacado(resultado);
          }
          registrarOperacao(`Elemento ${validacaoValor.valor} ${resultado >= 0 ? `encontrado no √≠ndice ${resultado}` : 'n√£o encontrado'}`);
          break;
        }

        default:
          throw new Error('M√©todo n√£o implementado');
      }

      // Remove o destaque ap√≥s 1.5 segundos
      if (indiceDestacado !== undefined) {
        setTimeout(() => setIndiceDestacado(undefined), 1500);
      }

      return resultado;
    } catch (erro) {
      const mensagem = erro instanceof Error ? erro.message : 'Erro desconhecido';
      setMensagemAcao(`Erro: ${mensagem}`);
      throw erro;
    }
  }, [elementos, capacidadeInicial, registrarOperacao, validarIndice]);

  // Interface p√∫blica do hook
  // Interface p√∫blica do hook
  return {
    elementos,                // Array atual de elementos do vetor
    historico,               // Hist√≥rico de opera√ß√µes realizadas
    mensagemAcao,           // Mensagem sobre a √∫ltima a√ß√£o executada
    indiceDestacado,        // √çndice atualmente destacado na visualiza√ß√£o
    executarMetodo,         // M√©todo principal para executar opera√ß√µes no vetor
    capacidadeMaxima: capacidadeInicial  // Capacidade m√°xima do vetor
  };
}


===== vetor.ts =====
// src/components/DataStructures/Vetor/vetor.ts
export class Vetor {
  private elementos: number[];
  private capacidade: number;
  
  constructor(capacidadeInicial: number = 10) {
    this.elementos = new Array(capacidadeInicial);
    this.capacidade = capacidadeInicial;
  }

  private validarNumeroInteiro(valor: number): void {
    if (!Number.isInteger(valor)) {
      throw new Error("Apenas n√∫meros inteiros s√£o permitidos");
    }
    if (valor < -1000 || valor > 1000) {
      throw new Error("O valor deve estar entre -1000 e 1000");
    }
  }

  private verificarCapacidade(): void {
    if (this.elementos.length >= this.capacidade) {
      this.capacidade *= 2;
      const novosElementos = new Array(this.capacidade);
      for (let i = 0; i < this.elementos.length; i++) {
        novosElementos[i] = this.elementos[i];
      }
      this.elementos = novosElementos;
    }
  }

  inserir(indice: number, elemento: number): void {
    if (indice < 0 || indice > this.elementos.length) {
      throw new Error("√çndice fora dos limites");
    }
    
    this.validarNumeroInteiro(elemento);
    this.verificarCapacidade();
    
    for (let i = this.elementos.length; i > indice; i--) {
      this.elementos[i] = this.elementos[i - 1];
    }
    this.elementos[indice] = elemento;
  }

  remover(indice: number): number {
    if (indice < 0 || indice >= this.elementos.length) {
      throw new Error("√çndice fora dos limites");
    }
    
    const removido = this.elementos[indice];
    for (let i = indice; i < this.elementos.length - 1; i++) {
      this.elementos[i] = this.elementos[i + 1];
    }
    this.elementos.length--;
    return removido;
  }

  buscar(elemento: number): number {
    this.validarNumeroInteiro(elemento);
    for (let i = 0; i < this.elementos.length; i++) {
      if (this.elementos[i] === elemento) {
        return i;
      }
    }
    return -1;
  }

  obter(indice: number): number {
    if (indice < 0 || indice >= this.elementos.length) {
      throw new Error("√çndice fora dos limites");
    }
    return this.elementos[indice];
  }

  definir(indice: number, elemento: number): void {
    if (indice < 0 || indice >= this.elementos.length) {
      throw new Error("√çndice fora dos limites");
    }
    this.validarNumeroInteiro(elemento);
    this.elementos[indice] = elemento;
  }

  tamanho(): number {
    return this.elementos.length;
  }

  estaVazio(): boolean {
    return this.elementos.length === 0;
  }

  limpar(): void {
    this.elementos = new Array(this.capacidade);
  }

  ordenar(): void {
    this.elementos.sort((a, b) => a - b);
  }

  inverter(): void {
    let inicio = 0;
    let fim = this.elementos.length - 1;
    
    while (inicio < fim) {
      const temp = this.elementos[inicio];
      this.elementos[inicio] = this.elementos[fim];
      this.elementos[fim] = temp;
      inicio++;
      fim--;
    }
  }

  adicionarNoFinal(elemento: number): void {
    this.validarNumeroInteiro(elemento);
    this.verificarCapacidade();
    this.elementos.push(elemento);
  }

  estender(elementos: number[]): void {
    for (const elemento of elementos) {
      this.validarNumeroInteiro(elemento);
    }
    for (const elemento of elementos) {
      this.adicionarNoFinal(elemento);
    }
  }

  removerDoFinal(): number {
    if (this.estaVazio()) {
      throw new Error("Vetor est√° vazio");
    }
    return this.elementos.pop()!;
  }

  fatiar(inicio: number, fim?: number): number[] {
    if (inicio < 0 || inicio >= this.elementos.length) {
      throw new Error("√çndice inicial fora dos limites");
    }
    
    const fimEfetivo = fim === undefined ? this.elementos.length : fim;
    if (fimEfetivo < inicio || fimEfetivo > this.elementos.length) {
      throw new Error("√çndice final inv√°lido");
    }

    return this.elementos.slice(inicio, fimEfetivo);
  }

  contem(elemento: number): boolean {
    this.validarNumeroInteiro(elemento);
    return this.buscar(elemento) !== -1;
  }

  indiceDe(elemento: number): number {
    this.validarNumeroInteiro(elemento);
    return this.buscar(elemento);
  }

  paraArray(): number[] {
    return [...this.elementos];
  }
}


===== VisualizacaoVetor.tsx =====
// src/components/DataStructures/Vetor/VisualizacaoVetor.tsx
import * as React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { gsap } from 'gsap';
import { Progress } from '@/components/ui/progress';
import { Slider } from '@/components/ui/slider';

interface VectorElement {
  value: number;
  id: string;
}

interface HistoryOperation {
  operacao: string;
  timestamp: number;
  status: OperationState;
}

interface MetodoVetor {
  id: string;
  titulo: string;
  icone: string;
  requisitos: string[];
  mensagemExplicativa: string;
}

enum OperationState {
  IDLE = 'idle',
  RUNNING = 'running',
  COMPLETED = 'completed',
  ERROR = 'error'
}

const validarNumeroInteiro = (valor: string): { valido: boolean; valor?: number; mensagem: string } => {
  if (!valor.trim()) {
    return { valido: false, mensagem: 'O valor n√£o pode estar vazio' };
  }

  const numero = Number(valor);

  if (isNaN(numero)) {
    return { valido: false, mensagem: 'O valor deve ser um n√∫mero inteiro' };
  }

  if (numero !== Math.floor(numero)) {
    return { valido: false, mensagem: 'O valor deve ser um n√∫mero inteiro' };
  }

  if (numero < -1000 || numero > 1000) {
    return { valido: false, mensagem: 'O valor deve estar entre -1000 e 1000' };
  }

  return { valido: true, valor: numero, mensagem: 'Valor v√°lido' };
};

const VisualizacaoVetor: React.FC = () => {
  const [elementos, setElementos] = React.useState<VectorElement[]>([]);
  const [metodoAtual, setMetodoAtual] = React.useState<string | null>(null);
  const [valor, setValor] = React.useState('');
  const [indice, setIndice] = React.useState('');
  const [indiceSecundario, setIndiceSecundario] = React.useState('');
  const [mensagemAcao, setMensagemAcao] = React.useState<string | null>(null);
  const [historico, setHistorico] = React.useState<HistoryOperation[]>([]);
  const [indiceDestacado, setIndiceDestacado] = React.useState<number | null>(null);
  const capacidade = 20;
  const [operationState, setOperationState] = React.useState<OperationState>(OperationState.IDLE);
  const [progress, setProgress] = React.useState(0);
  const [animationSpeed, setAnimationSpeed] = React.useState(1);
  const [animationTimeline, setAnimationTimeline] = React.useState<gsap.core.Timeline | null>(null);
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  const metodosDisponiveis: MetodoVetor[] = [
    { id: 'inserir', titulo: 'Inserir', icone: '‚¨á', requisitos: ['valor', 'indice'], mensagemExplicativa: 'Insira o valor (n√∫mero inteiro) e a posi√ß√£o onde deseja inserir o elemento no vetor.' },
    { id: 'remover', titulo: 'Remover', icone: 'üóë', requisitos: ['indice'], mensagemExplicativa: 'Digite a posi√ß√£o do elemento que deseja remover do vetor.' },
    { id: 'buscar', titulo: 'Buscar', icone: 'üîç', requisitos: ['valor'], mensagemExplicativa: 'Digite o valor (n√∫mero inteiro) que deseja buscar no vetor.' },
    { id: 'obterElemento', titulo: 'Obter Elemento', icone: 'üëÅ', requisitos: ['indice'], mensagemExplicativa: 'Digite o √≠ndice do elemento que deseja obter.' },
    { id: 'definirElemento', titulo: 'Definir Elemento', icone: '‚úèÔ∏è', requisitos: ['valor', 'indice'], mensagemExplicativa: 'Informe o √≠ndice e o novo valor (n√∫mero inteiro) que substituir√° o elemento.' },
    { id: 'tamanho', titulo: 'Tamanho', icone: 'üìè', requisitos: [], mensagemExplicativa: 'Clique para ver o tamanho do vetor.' },
    { id: 'estaVazio', titulo: 'Est√° Vazio', icone: '‚ùì', requisitos: [], mensagemExplicativa: 'Clique para verificar se o vetor est√° vazio.' },
    { id: 'limpar', titulo: 'Limpar', icone: 'üßπ', requisitos: [], mensagemExplicativa: 'Clique para limpar (remover) todos os elementos do vetor.' },
    { id: 'ordenar', titulo: 'Ordenar', icone: 'üìä', requisitos: [], mensagemExplicativa: 'Clique para ordenar os elementos do vetor.' },
    { id: 'inverter', titulo: 'Inverter', icone: 'üîÑ', requisitos: [], mensagemExplicativa: 'Clique para inverter a ordem dos elementos do vetor.' },
    { id: 'adicionarNoFinal', titulo: 'Adicionar no Final', icone: '‚ûï', requisitos: ['valor'], mensagemExplicativa: 'Insira o valor (n√∫mero inteiro) que deseja adicionar no final do vetor.' },
    { id: 'estender', titulo: 'Estender', icone: 'üìë', requisitos: ['valor'], mensagemExplicativa: 'Digite os valores (n√∫meros inteiros) separados por v√≠rgula.' },
    { id: 'removerDoFinal', titulo: 'Remover do Final', icone: '‚õî', requisitos: [], mensagemExplicativa: 'Clique para remover o √∫ltimo elemento do vetor.' },
    { id: 'fatiar', titulo: 'Fatiar', icone: '‚úÇÔ∏è', requisitos: ['indice', 'indiceSecundario'], mensagemExplicativa: 'Digite o √≠ndice inicial e final para fatiar.' },
    { id: 'contem', titulo: 'Cont√©m', icone: 'üéØ', requisitos: ['valor'], mensagemExplicativa: 'Digite o valor (n√∫mero inteiro) que deseja verificar se ele est√° contido no vetor.' },
    { id: 'indiceDe', titulo: '√çndice De', icone: 'üî¢', requisitos: ['valor'], mensagemExplicativa: 'Digite o valor (n√∫mero inteiro) para localiza√ß√£o do √≠ndice dele no vetor.' }
  ];

  React.useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    const handleChange = (e: MediaQueryListEvent) => {
      setAnimationSpeed(e.matches ? 0.5 : 1);
      gsap.globalTimeline.timeScale(e.matches ? 0.5 : 1);
    };
    mediaQuery.addEventListener('change', handleChange);
    const tl = gsap.timeline({ paused: true });
    setAnimationTimeline(tl);
    return () => {
      mediaQuery.removeEventListener('change', handleChange);
      tl.kill();
    };
  }, []);

  React.useEffect(() => {
    if (animationTimeline) {
      animationTimeline.timeScale(animationSpeed);
    }
    gsap.globalTimeline.timeScale(animationSpeed);
  }, [animationSpeed, animationTimeline]);

  const registrarOperacao = React.useCallback((operacao: string, state: OperationState = OperationState.COMPLETED): void => {
    setHistorico(prev => [{ operacao, timestamp: Date.now(), status: state }, ...prev]);
    setMensagemAcao(operacao);
    setOperationState(state);
    if (!prefersReducedMotion) {
      gsap.from('.historico-item:first-child', { opacity: 0, y: -20, duration: 0.3 * animationSpeed, ease: 'power2.out' });
    }
  }, [animationSpeed, prefersReducedMotion]);

  const animateProgress = React.useCallback(async (duration: number = 1000) => {
    if (prefersReducedMotion) {
      setProgress(100);
      return;
    }
    const steps = 50;
    const stepDuration = duration / steps;
    for (let i = 1; i <= steps; i++) {
      await new Promise(resolve => setTimeout(resolve, stepDuration * animationSpeed));
      setProgress((i / steps) * 100);
    }
  }, [animationSpeed, prefersReducedMotion]);

  const VectorCell: React.FC<{ index: number; element?: VectorElement; highlighted: boolean; state: OperationState; }> = React.memo(({ index, element, highlighted, state }) => {
    const cellRef = React.useRef<HTMLDivElement>(null);

    React.useEffect(() => {
      if (cellRef.current && highlighted && !prefersReducedMotion) {
        gsap.to(cellRef.current, { scale: 1.1, duration: 0.3 * animationSpeed, yoyo: true, repeat: 1, ease: 'power2.inOut' });
      }
    }, [highlighted]);

    const getCellColor = () => {
      if (!element) return '#4A5568';
      switch (state) {
        case OperationState.RUNNING: return highlighted ? '#4299E1' : '#63B3ED';
        case OperationState.COMPLETED: return highlighted ? '#9F7AEA' : '#805AD5';
        case OperationState.ERROR: return highlighted ? '#F56565' : '#E53E3E';
        default: return highlighted ? '#9F7AEA' : '#805AD5';
      }
    };

    return (
      <motion.div
        ref={cellRef}
        initial={{ scale: 0.8, opacity: 0 }}
        animate={{ scale: 1, opacity: 1, backgroundColor: getCellColor() }}
        transition={{ duration: 0.3 * animationSpeed }}
        className={`w-14 h-14 rounded relative flex items-center justify-center ${highlighted ? 'ring-2 ring-blue-400' : ''} transition-colors duration-300`}
        aria-label={element ? `C√©lula ${index} contendo ${element.value}` : `C√©lula ${index} vazia`}
      >
        <span className="absolute top-1 left-1 text-xs text-white/80">{index}</span>
        <span className="text-white font-medium">{element?.value}</span>
      </motion.div>
    );
  });

  const executarMetodo = React.useCallback(async () => {
    if (!metodoAtual) return;

    try {
      setOperationState(OperationState.RUNNING);
      setProgress(0);
      await animateProgress(1000);

      if (animationTimeline) {
        animationTimeline.clear();
      }

      switch (metodoAtual) {
        case 'inserir': {
          if (!valor || !indice) {
            setOperationState(OperationState.ERROR);
            throw new Error('Preencha todos os campos');
          }
          const validacao = validarNumeroInteiro(valor);
          if (!validacao.valido) {
            setOperationState(OperationState.ERROR);
            throw new Error(validacao.mensagem);
          }

          const idx = parseInt(indice);
          if (isNaN(idx)) {
            setOperationState(OperationState.ERROR);
            throw new Error('√çndice inv√°lido');
          }
          if (idx < 0 || idx > elementos.length) {
            setOperationState(OperationState.ERROR);
            throw new Error('√çndice fora dos limites');
          }
          if (elementos.length >= capacidade) {
            setOperationState(OperationState.ERROR);
            throw new Error('Vetor est√° cheio');
          }

          const novosElementos = [...elementos];
          const novoElemento = { value: validacao.valor!, id: Date.now().toString() };

          await new Promise(resolve => setTimeout(resolve, 300 * animationSpeed));
          novosElementos.splice(idx, 0, novoElemento);
          setElementos(novosElementos);
          setIndiceDestacado(idx);
          registrarOperacao(`Elemento ${validacao.valor} inserido na posi√ß√£o ${idx}`, OperationState.COMPLETED);
          break;
        }

        case 'remover': {
          if (!indice) {
            setOperationState(OperationState.ERROR);
            throw new Error('Informe o √≠ndice');
          }
          const idx = parseInt(indice);
          if (isNaN(idx)) {
            setOperationState(OperationState.ERROR);
            throw new Error('√çndice inv√°lido');
          }
          if (idx < 0 || idx >= elementos.length) {
            setOperationState(OperationState.ERROR);
            throw new Error('√çndice fora dos limites');
          }

          const elementoRemovido = elementos[idx].value;
          setIndiceDestacado(idx);

          await new Promise(resolve => setTimeout(resolve, 300 * animationSpeed));

          const novosElementos = [...elementos];
          novosElementos.splice(idx, 1);
          setElementos(novosElementos);
          registrarOperacao(`Elemento ${elementoRemovido} removido da posi√ß√£o ${idx}`, OperationState.COMPLETED);
          break;
        }

        case 'buscar': {
          if (!valor) {
            setOperationState(OperationState.ERROR);
            throw new Error('Informe o valor para buscar');
          }
          const validacao = validarNumeroInteiro(valor);
          if (!validacao.valido) {
            setOperationState(OperationState.ERROR);
            throw new Error(validacao.mensagem);
          }

          for (let i = 0; i < elementos.length && !prefersReducedMotion; i++) {
            setIndiceDestacado(i);
            await new Promise(resolve => setTimeout(resolve, 200 * animationSpeed));
            if (elementos[i].value === validacao.valor) break;
          }

          const encontrado = elementos.findIndex(el => el.value === validacao.valor);
          if (encontrado >= 0) {
            setIndiceDestacado(encontrado);
            registrarOperacao(`Elemento ${validacao.valor} encontrado na posi√ß√£o ${encontrado}`, OperationState.COMPLETED);
          } else {
            registrarOperacao(`Elemento ${validacao.valor} n√£o encontrado`, OperationState.COMPLETED);
          }
          break;
        }

        case 'obterElemento': {
          if (!indice) {
            setOperationState(OperationState.ERROR);
            throw new Error('Informe o √≠ndice');
          }
          const idx = parseInt(indice);
          if (isNaN(idx)) {
            setOperationState(OperationState.ERROR);
            throw new Error('√çndice inv√°lido');
          }
          if (idx < 0 || idx >= elementos.length) {
            setOperationState(OperationState.ERROR);
            throw new Error('√çndice fora dos limites');
          }

          setIndiceDestacado(idx);
          await new Promise(resolve => setTimeout(resolve, 300 * animationSpeed));

          registrarOperacao(`Elemento na posi√ß√£o ${idx}: ${elementos[idx].value}`, OperationState.COMPLETED);
          break;
        }

        case 'definirElemento': {
          if (!valor || !indice) {
            setOperationState(OperationState.ERROR);
            throw new Error('Preencha todos os campos');
          }
          const validacao = validarNumeroInteiro(valor);
          if (!validacao.valido) {
            setOperationState(OperationState.ERROR);
            throw new Error(validacao.mensagem);
          }

          const idx = parseInt(indice);
          if (isNaN(idx)) {
            setOperationState(OperationState.ERROR);
            throw new Error('√çndice inv√°lido');
          }
          if (idx < 0 || idx >= elementos.length) {
            setOperationState(OperationState.ERROR);
            throw new Error('√çndice fora dos limites');
          }

          setIndiceDestacado(idx);
          await new Promise(resolve => setTimeout(resolve, 300 * animationSpeed));

          const novosElementos = [...elementos];
          novosElementos[idx] = { value: validacao.valor!, id: Date.now().toString() };
          setElementos(novosElementos);
          registrarOperacao(`Elemento na posi√ß√£o ${idx} atualizado para ${validacao.valor}`, OperationState.COMPLETED);
          break;
        }

        case 'tamanho': {
          if (!prefersReducedMotion) {
            for (let i = 0; i < elementos.length; i++) {
              setIndiceDestacado(i);
              await new Promise(resolve => setTimeout(resolve, 100 * animationSpeed));
            }
          }
          setIndiceDestacado(null);
          registrarOperacao(`Tamanho atual do vetor: ${elementos.length}`, OperationState.COMPLETED);
          break;
        }

        case 'estaVazio': {
          const vazio = elementos.length === 0;
          if (!vazio && !prefersReducedMotion) {
            for (let i = 0; i < elementos.length; i++) {
              setIndiceDestacado(i);
              await new Promise(resolve => setTimeout(resolve, 100 * animationSpeed));
            }
          }
          setIndiceDestacado(null);
          registrarOperacao(`O vetor ${vazio ? 'est√°' : 'n√£o est√°'} vazio`, OperationState.COMPLETED);
          break;
        }

        case 'limpar': {
          if (!prefersReducedMotion) {
            while (elementos.length > 0) {
              setIndiceDestacado(elementos.length - 1);
              await new Promise(resolve => setTimeout(resolve, 100 * animationSpeed));
              setElementos(prev => prev.slice(0, -1));
            }
          } else {
            setElementos([]);
          }
          setIndiceDestacado(null);
          registrarOperacao('Vetor foi limpo', OperationState.COMPLETED);
          break;
        }

        case 'ordenar': {
          if (elementos.length === 0) {
            setOperationState(OperationState.ERROR);
            throw new Error('Vetor est√° vazio');
          }

          const novosElementos = [...elementos];
          if (!prefersReducedMotion) {
            for (let i = 0; i < novosElementos.length; i++) {
              for (let j = 0; j < novosElementos.length - i - 1; j++) {
                setIndiceDestacado(j);
                await new Promise(resolve => setTimeout(resolve, 100 * animationSpeed));
                if (novosElementos[j].value > novosElementos[j + 1].value) {
                  const temp = novosElementos[j];
                  novosElementos[j] = novosElementos[j + 1];
                  novosElementos[j + 1] = temp;
                  setElementos([...novosElementos]);
                }
              }
            }
          } else {
            novosElementos.sort((a, b) => a.value - b.value);
            setElementos(novosElementos);
          }

          setIndiceDestacado(null);
          registrarOperacao('Vetor ordenado', OperationState.COMPLETED);
          break;
        }

        case 'inverter': {
          if (elementos.length === 0) {
            setOperationState(OperationState.ERROR);
            throw new Error('Vetor est√° vazio');
          }

          const novosElementos = [...elementos];
          if (!prefersReducedMotion) {
            for (let i = 0; i < Math.floor(novosElementos.length / 2); i++) {
              setIndiceDestacado(i);
              await new Promise(resolve => setTimeout(resolve, 200 * animationSpeed));
              const temp = novosElementos[i];
              novosElementos[i] = novosElementos[novosElementos.length - 1 - i];
              novosElementos[novosElementos.length - 1 - i] = temp;
              setElementos([...novosElementos]);
              setIndiceDestacado(novosElementos.length - 1 - i);
              await new Promise(resolve => setTimeout(resolve, 200 * animationSpeed));
            }
          } else {
            setElementos(novosElementos.reverse());
          }

          setIndiceDestacado(null);
          registrarOperacao('Vetor invertido', OperationState.COMPLETED);
          break;
        }

        case 'adicionarNoFinal': {
          if (!valor) {
            setOperationState(OperationState.ERROR);
            throw new Error('Informe o valor');
          }
          const validacao = validarNumeroInteiro(valor);
          if (!validacao.valido) {
            setOperationState(OperationState.ERROR);
            throw new Error(validacao.mensagem);
          }

          if (elementos.length >= capacidade) {
            setOperationState(OperationState.ERROR);
            throw new Error('Vetor est√° cheio');
          }

          setIndiceDestacado(elementos.length);
          await new Promise(resolve => setTimeout(resolve, 300 * animationSpeed));

          setElementos([...elementos, { value: validacao.valor!, id: Date.now().toString() }]);
          registrarOperacao(`Elemento ${validacao.valor} adicionado ao final`, OperationState.COMPLETED);
          break;
        }

        case 'estender': {
          if (!valor) {
            setOperationState(OperationState.ERROR);
            throw new Error('Informe os valores separados por v√≠rgula');
          }
          const valoresBrutos = valor.split(',').map(v => v.trim());

          const valoresValidados = [];
          for (const valorBruto of valoresBrutos) {
            const validacao = validarNumeroInteiro(valorBruto);
            if (!validacao.valido) {
              setOperationState(OperationState.ERROR);
              throw new Error(`Valor inv√°lido na lista: ${valorBruto} - ${validacao.mensagem}`);
            }
            valoresValidados.push(validacao.valor!);
          }

          if (elementos.length + valoresValidados.length > capacidade) {
            setOperationState(OperationState.ERROR);
            throw new Error('Capacidade seria excedida');
          }

          for (const valor of valoresValidados) {
            setIndiceDestacado(elementos.length);
            await new Promise(resolve => setTimeout(resolve, 200 * animationSpeed));
            setElementos(prev => [...prev, { value: valor, id: Date.now().toString() + Math.random() }]);
          }

          registrarOperacao(`${valoresValidados.length} elementos adicionados ao final`, OperationState.COMPLETED);
          break;
        }

        case 'removerDoFinal': {
          if (elementos.length === 0) {
            setOperationState(OperationState.ERROR);
            throw new Error('Vetor est√° vazio');
          }

          setIndiceDestacado(elementos.length - 1);
          await new Promise(resolve => setTimeout(resolve, 300 * animationSpeed));

          const removido = elementos[elementos.length - 1].value;
          setElementos(prev => prev.slice(0, -1));
          registrarOperacao(`Elemento ${removido} removido do final`, OperationState.COMPLETED);
          break;
        }

        case 'fatiar': {
          if (!indice || !indiceSecundario) {
            setOperationState(OperationState.ERROR);
            throw new Error('Informe os √≠ndices inicial e final');
          }
          const inicio = parseInt(indice);
          const fim = parseInt(indiceSecundario);

          if (isNaN(inicio) || isNaN(fim)) {
            setOperationState(OperationState.ERROR);
            throw new Error('√çndices inv√°lidos');
          }
          if (inicio < 0 || inicio >= elementos.length) {
            setOperationState(OperationState.ERROR);
            throw new Error('√çndice inicial inv√°lido');
          }
          if (fim < inicio || fim > elementos.length) {
            setOperationState(OperationState.ERROR);
            throw new Error('√çndice final inv√°lido');
          }

          if (!prefersReducedMotion) {
            for (let i = inicio; i < fim; i++) {
              setIndiceDestacado(i);
              await new Promise(resolve => setTimeout(resolve, 100 * animationSpeed));
            }
          }

          const elementosFatiados = elementos.slice(inicio, fim);
          setIndiceDestacado(null);
          registrarOperacao(
            `Vetor fatiado: [${elementosFatiados.map(el => el.value).join(', ')}]`,
            OperationState.COMPLETED
          );
          break;
        }

        case 'contem': {
          if (!valor) {
            setOperationState(OperationState.ERROR);
            throw new Error('Informe o valor para verificar');
          }
          const validacao = validarNumeroInteiro(valor);
          if (!validacao.valido) {
            setOperationState(OperationState.ERROR);
            throw new Error(validacao.mensagem);
          }

          if (!prefersReducedMotion) {
            for (let i = 0; i < elementos.length; i++) {
              setIndiceDestacado(i);
              await new Promise(resolve => setTimeout(resolve, 200 * animationSpeed));
              if (elementos[i].value === validacao.valor) break;
            }
          }

          const contem = elementos.some(el => el.value === validacao.valor);
          setIndiceDestacado(null);
          registrarOperacao(
            `O vetor ${contem ? 'cont√©m' : 'n√£o cont√©m'} o elemento ${validacao.valor}`,
            OperationState.COMPLETED
          );
          break;
        }

        case 'indiceDe': {
          if (!valor) {
            setOperationState(OperationState.ERROR);
            throw new Error('Informe o valor para buscar');
          }
          const validacao = validarNumeroInteiro(valor);
          if (!validacao.valido) {
            setOperationState(OperationState.ERROR);
            throw new Error(validacao.mensagem);
          }

          let indiceEncontrado = -1;
          if (!prefersReducedMotion) {
            for (let i = 0; i < elementos.length; i++) {
              setIndiceDestacado(i);
              await new Promise(resolve => setTimeout(resolve, 200 * animationSpeed));
              if (elementos[i].value === validacao.valor) {
                indiceEncontrado = i;
                break;
              }
            }
          } else {
            indiceEncontrado = elementos.findIndex(el => el.value === validacao.valor);
          }

          if (indiceEncontrado >= 0) {
            setIndiceDestacado(indiceEncontrado);
            registrarOperacao(
              `Primeira ocorr√™ncia do elemento ${validacao.valor} est√° no √≠ndice ${indiceEncontrado}`,
              OperationState.COMPLETED
            );
          } else {
            setIndiceDestacado(null);
            registrarOperacao(
              `Elemento ${validacao.valor} n√£o encontrado`,
              OperationState.COMPLETED
            );
          }
          break;
        }

        default:
          setOperationState(OperationState.ERROR);
          throw new Error('M√©todo n√£o implementado');
      }

      setValor('');
      setIndice('');
      setIndiceSecundario('');

      if (indiceDestacado !== null) {
        setTimeout(() => setIndiceDestacado(null), 1500 * animationSpeed);
      }

      setOperationState(OperationState.COMPLETED);
      setProgress(100);

    } catch (erro: unknown) {
      setOperationState(OperationState.ERROR);
      if (erro instanceof Error) {
        setMensagemAcao(`Erro: ${erro.message}`);
      } else {
        setMensagemAcao('Erro desconhecido');
      }
      setProgress(100);
    }
  }, [
    metodoAtual,
    elementos,
    valor,
    indice,
    indiceSecundario,
    indiceDestacado,
    capacidade,
    registrarOperacao,
    animationSpeed,
    prefersReducedMotion,
    animationTimeline,
    animateProgress
  ]);

  return (
    <div className="p-4 bg-gray-900 text-white min-h-screen">
      <div className="mb-6">
        <div className="flex justify-between items-center">
          <button
            onClick={() => window.history.back()}
            className="flex items-center gap-2 px-3 py-2 text-gray-400 hover:text-white rounded-lg border border-gray-700 hover:bg-gray-800 transition-colors"
            aria-label="Voltar para a p√°gina inicial"
          >
            <span>‚Üê</span>
            Voltar
          </button>

          <button
            onClick={() => window.close()}
            className="flex items-center gap-2 px-4 py-2 text-red-400 hover:text-white rounded-lg border border-red-700 hover:bg-red-700 transition-colors"
            aria-label="Sair da aplica√ß√£o"
          >
            <span>‚úï</span>
            Sair
          </button>
        </div>

        <h1 className="text-xl font-bold mt-4">Vetor</h1>
        <p className="mt-4">Estrutura linear com elementos em posi√ß√µes cont√≠guas de mem√≥ria.</p>
        <span className="text-purple-400">16 m√©todos dispon√≠veis</span>
      </div>

      <div className="mb-4 bg-gray-800 p-4 rounded-lg">
        <label className="block text-sm font-medium mb-2">
          Velocidade das Anima√ß√µes
          <span className="ml-2 text-gray-400">
            {prefersReducedMotion ? '(Movimento reduzido ativado)' : ''}
          </span>
        </label>
        <Slider
          value={[animationSpeed]}
          min={0.5}
          max={2}
          step={0.1}
          onValueChange={([value]) => setAnimationSpeed(value)}
          className="w-full"
          aria-label="Ajustar velocidade das anima√ß√µes"
        />
        <div className="mt-1 text-xs text-gray-400 flex justify-between">
          <span>Mais Lento (0.5x)</span>
          <span>{animationSpeed.toFixed(1)}x</span>
          <span>Mais R√°pido (2x)</span>
        </div>
      </div>

      <div className="mb-6 bg-gray-800 p-4 rounded-lg">
        {operationState === OperationState.RUNNING && (
          <motion.div initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} className="mb-4">
            <Progress value={progress} className="w-full" />
            <p className="text-sm text-blue-400 mt-1">Opera√ß√£o em andamento...</p>
          </motion.div>
        )}

        <div className="flex flex-wrap gap-2">
          <AnimatePresence>
            {Array.from({ length: capacidade }).map((_, index) => (
              <VectorCell
                key={`cell-${index}`}
                index={index}
                element={elementos[index]}
                highlighted={indiceDestacado === index}
                state={operationState}
              />
            ))}
          </AnimatePresence>
        </div>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2 mb-6">
        {metodosDisponiveis.map(metodo => (
          <motion.button
            key={metodo.id}
            onClick={() => setMetodoAtual(metodo.id)}
            className={`p-2 rounded text-left flex items-center gap-2 ${metodoAtual === metodo.id ? 'bg-purple-600' : 'bg-gray-700'} hover:bg-purple-500 transition-colors`}
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
            aria-label={`Selecionar m√©todo ${metodo.titulo}`}
          >
            <span role="img" aria-hidden="true">{metodo.icone}</span>
            <span>{metodo.titulo}</span>
          </motion.button>
        ))}
      </div>

      {metodoAtual && (
        <motion.div initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} className="mb-6 bg-gray-800 p-4 rounded">
          <p className="text-gray-300 mb-4">
            {metodosDisponiveis.find(m => m.id === metodoAtual)?.mensagemExplicativa}
          </p>
          <div className="flex flex-wrap md:flex-nowrap items-center gap-4">
            {metodosDisponiveis.find(m => m.id === metodoAtual)?.requisitos.includes('valor') && (
              <input
                type="text"
                value={valor}
                onChange={(e) => setValor(e.target.value)}
                placeholder="Digite um n√∫mero inteiro"
                className="flex-1 bg-gray-700 p-2 rounded border-none text-white min-w-[120px] focus:ring-2 focus:ring-purple-500 outline-none"
                aria-label="Valor para a opera√ß√£o (apenas n√∫meros inteiros)"
              />
            )}

            {metodosDisponiveis.find(m => m.id === metodoAtual)?.requisitos.includes('indice') && (
              <input
                type="number"
                value={indice}
                onChange={(e) => setIndice(e.target.value)}
                placeholder="√çndice"
                className="flex-1 bg-gray-700 p-2 rounded border-none text-white min-w-[120px] focus:ring-2 focus:ring-purple-500 outline-none"
                aria-label="√çndice para a opera√ß√£o"
              />
            )}

            {metodosDisponiveis.find(m => m.id === metodoAtual)?.requisitos.includes('indiceSecundario') && (
              <input
                type="number"
                value={indiceSecundario}
                onChange={(e) => setIndiceSecundario(e.target.value)}
                placeholder="√çndice Final"
                className="flex-1 bg-gray-700 p-2 rounded border-none text-white min-w-[120px] focus:ring-2 focus:ring-purple-500 outline-none"
                aria-label="√çndice final para a opera√ß√£o"
              />
            )}

            <motion.button
              onClick={executarMetodo}
              className={`px-6 py-2 rounded text-white transition-colors ${
                operationState === OperationState.RUNNING
                  ? 'bg-blue-600 cursor-not-allowed'
                  : 'bg-purple-6                0 hover:bg-purple-700'
              }`}
              whileHover={operationState !== OperationState.RUNNING ? { scale: 1.02 } : {}}
              whileTap={operationState !== OperationState.RUNNING ? { scale: 0.98 } : {}}
              disabled={operationState === OperationState.RUNNING}
              aria-label={`Executar ${metodosDisponiveis.find(m => m.id === metodoAtual)?.titulo}`}
            >
              {operationState === OperationState.RUNNING ? 'Executando...' : 'Executar'}
            </motion.button>
          </div>
        </motion.div>
      )}

      <AnimatePresence>
        {mensagemAcao && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            className="mb-6 bg-gray-800 p-3 rounded"
          >
            <p
              className={`${
                operationState === OperationState.ERROR ? 'text-red-400' :
                  operationState === OperationState.COMPLETED ? 'text-green-400' :
                    'text-blue-400'
              }`}
              role="alert"
            >
              {mensagemAcao}
            </p>
          </motion.div>
        )}
      </AnimatePresence>

      <div className="flex flex-wrap md:flex-nowrap gap-4 mb-6">
        <motion.div
          className="flex-1 bg-gray-800 p-3 rounded flex items-center justify-between min-w-[150px]"
          whileHover={{ scale: 1.02 }}
        >
          <span className="text-blue-400">Tamanho:</span>
          <span>{elementos.length}</span>
        </motion.div>
        <motion.div
          className="flex-1 bg-gray-800 p-3 rounded flex items-center justify-between min-w-[150px]"
          whileHover={{ scale: 1.02 }}
        >
          <span className="text-blue-400">Capacidade:</span>
          <span>{capacidade}</span>
        </motion.div>
        <motion.div
          className="flex-1 bg-gray-800 p-3 rounded flex items-center justify-between min-w-[150px]"
          whileHover={{ scale: 1.02 }}
        >
          <span className="text-blue-400">Estado:</span>
          <span>{elementos.length > 0 ? 'Com elementos' : 'Vazio'}</span>
        </motion.div>
      </div>

      <motion.div
        className="bg-gray-800 p-4 rounded"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
      >
        <h3 className="text-lg font-bold mb-3">Hist√≥rico de Opera√ß√µes</h3>
        <div className="space-y-2 max-h-40 overflow-y-auto">
          {historico.map((op, index) => (
            <motion.div
              key={index}
              className={`bg-gray-700 p-2 rounded historico-item ${op.status === OperationState.ERROR ? 'border-l-4 border-red-500' : op.status === OperationState.COMPLETED ? 'border-l-4 border-green-500' : 'border-l-4 border-blue-500'}`}
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: index * 0.1 }}
            >
              <div className="flex justify-between items-center">
                <span>{op.operacao}</span>
                <span className="text-xs text-gray-400">
                  {new Date(op.timestamp).toLocaleTimeString()}
                </span>
              </div>
            </motion.div>
          ))}
        </div>
      </motion.div>
    </div>
  );
};

export default VisualizacaoVetor;


